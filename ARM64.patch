diff --git a/ARMv9.py b/ARMv9.py
index 376425c03ff5b0c68d382a2034f66c016dfb1e6b..b06d59486ec63534a9955d44a528f18230d7011a 100644
--- a/ARMv9.py
+++ b/ARMv9.py
@@ -1,51 +1,69 @@
 #!/usr/bin/env python3
 """
 GEMi - ARM64/ARMv9 Instruction Explorer & Analyzer
 -------------------------------------------------
 - Systematically vary instruction fields (registers, immediates, cond, etc.)
 - Visualize fixed vs variable bits with mask-based patterns
 - Summarize encodings and field layouts
 - Group exploration (branch, loadstore, dataproc, etc.)
 - Lock specific fields to known values for targeted drilling
 - Handle common aliases (CMP -> SUBS, TST -> ANDS, etc.)
 - NEW: ARMv9 support (SVE, MTE)
 - NEW: Hex <-> Assembly conversion and interactive mode
 - NEW: Basic instruction result calculation/emulation
 
 Key color legend in exploration output:
   normal bit : matches base encoding's bit in a fixed position
   \x1b[1;33mY\x1b[0m : bit differs from base, but that position is NOT fixed by mask (i.e. a legal varying field)
   \x1b[1;31mY\x1b[0m : bit differs from base where the mask SAYS it should be fixed (means: you've wandered out of class)
 """
 
 import argparse
 import itertools
 import struct
 import re
 import sys
-from capstone import Cs, CS_ARCH_ARM64, CS_MODE_ARM
+
+try:
+    from capstone import Cs, CS_ARCH_ARM64, CS_MODE_ARM
+except ModuleNotFoundError:
+    Cs = None
+    CS_ARCH_ARM64 = None
+    CS_MODE_ARM = None
+
+
+def _create_disassembler():
+    """Build a Capstone disassembler instance or raise a helpful error."""
+    if Cs is None:
+        raise RuntimeError(
+            "Capstone is required for disassembly features. Install it with 'pip install capstone'."
+        )
+
+    cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)
+    cs.detail = True
+    return cs
 
 
 # ============================================================
 # CORRECTED ISA GROUP DEFINITIONS
 # ============================================================
 # ... (ISA_GROUPS, OPCODE_MAP, GROUP_MAP, FIELD_SEMANTICS, INSTRUCTION_ALIASES remain the same as your last provided version) ...
 ISA_GROUPS = {
     "DataProcReg": [
         {
             "name": "ADD",
             "base": 0x0B000000,
             "mask": 0x7FE00000, # Mask corrected based on encoding diagrams
             "form": "register",
             "desc": "ADD (register): Rd = Rn + Rm [+ optional shift]",
             "fields": {
                 "Rd":    (0, 5),
                 "Rn":    (5, 5),
                 "Rm":    (16, 5),
                 "imm6":  (10, 6), # Shift amount
                 "shift": (22, 2), # Shift type
                 "sf":    (31, 1),
             },
         },
         {
             "name": "ADDS",
@@ -785,251 +803,288 @@ class Emulator:
         elif reg_name.startswith('X'):
             self.regs[reg_name] = value
         elif reg_name.startswith('W'):
              # Write lower 32 bits, zero upper 32
              reg_num = reg_name[1:]
              x_reg = 'X' + reg_num
              self.regs[x_reg] = value & 0xFFFFFFFF
         elif reg_name == 'SP':
             self.regs['SP'] = value
 
     def execute(self, mnemonic, op_str):
         """Execute a simple instruction and return result string"""
         mnemonic = mnemonic.upper()
         op_str_parts = [p.strip() for p in op_str.split(',')]
         result_str = ""
 
         try:
             # --- Arithmetic ---
             if mnemonic == 'ADD' and '#' in op_str: # ADD Xd, Xn, #imm
                 rd, rn, imm_str = op_str_parts
                 imm_val = int(imm_str.replace('#',''), 0)
                 rn_val = self.get_reg(rn)
                 result = (rn_val + imm_val) & 0xFFFFFFFFFFFFFFFF
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} + {imm_str} = {rn_val:#x} + {imm_val:#x} = {result:#x}"
+
             elif mnemonic == 'ADD' and len(op_str_parts) == 3: # ADD Xd, Xn, Xm
                 rd, rn, rm = op_str_parts
                 rn_val = self.get_reg(rn)
                 rm_val = self.get_reg(rm)
                 result = (rn_val + rm_val) & 0xFFFFFFFFFFFFFFFF
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} + {rm} = {rn_val:#x} + {rm_val:#x} = {result:#x}"
+
             elif mnemonic == 'SUB' and '#' in op_str: # SUB Xd, Xn, #imm
                 rd, rn, imm_str = op_str_parts
                 imm_val = int(imm_str.replace('#',''), 0)
                 rn_val = self.get_reg(rn)
                 result = (rn_val - imm_val) & 0xFFFFFFFFFFFFFFFF
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} - {imm_str} = {rn_val:#x} - {imm_val:#x} = {result:#x}"
+
             elif mnemonic == 'SUB' and len(op_str_parts) == 3: # SUB Xd, Xn, Xm
                 rd, rn, rm = op_str_parts
                 rn_val = self.get_reg(rn)
                 rm_val = self.get_reg(rm)
                 result = (rn_val - rm_val) & 0xFFFFFFFFFFFFFFFF
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} - {rm} = {rn_val:#x} - {rm_val:#x} = {result:#x}"
 
             # --- Moves ---
-            elif mnemonic == 'MOV' and '#' in op_str: # MOV Xd, #imm (uses MOVZ typically)
+            elif mnemonic == 'MOV' and '#' in op_str: # MOV Xd, #imm
                 rd, imm_str = op_str_parts
                 imm_val = int(imm_str.replace('#',''), 0)
-                # Simple MOVZ implementation assumes imm fits in 16 bits
-                if 0 <= imm_val <= 0xFFFF:
-                     self.set_reg(rd, imm_val)
-                     result_str = f"; {rd} = {imm_val:#x}"
-                else: # Need MOVN/MOVK sequence, not simulated here
-                     result_str = f"; {rd} = {imm_val:#x} (complex immediate)"
+                self.set_reg(rd, imm_val)
+                result_str = f"; {rd} = {imm_val:#x}"
 
             elif mnemonic == 'MOV' and len(op_str_parts) == 2: # MOV Xd, Xn
-                 rd, rn = op_str_parts
-                 rn_val = self.get_reg(rn)
-                 self.set_reg(rd, rn_val)
-                 result_str = f"; {rd} = {rn} = {rn_val:#x}"
+                rd, rn = op_str_parts
+                rn_val = self.get_reg(rn)
+                self.set_reg(rd, rn_val)
+                result_str = f"; {rd} = {rn} = {rn_val:#x}"
 
             # --- Logical ---
-            elif mnemonic == 'AND' and '#' not in op_str: # AND Xd, Xn, Xm
+            elif mnemonic == 'AND' and len(op_str_parts) == 3: # AND Xd, Xn, Xm
                 rd, rn, rm = op_str_parts
                 rn_val = self.get_reg(rn)
                 rm_val = self.get_reg(rm)
                 result = rn_val & rm_val
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} & {rm} = {rn_val:#x} & {rm_val:#x} = {result:#x}"
-            elif mnemonic == 'ORR' and '#' not in op_str: # ORR Xd, Xn, Xm
+
+            elif mnemonic == 'ORR' and len(op_str_parts) == 3: # ORR Xd, Xn, Xm
                 rd, rn, rm = op_str_parts
                 rn_val = self.get_reg(rn)
                 rm_val = self.get_reg(rm)
                 result = rn_val | rm_val
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} | {rm} = {rn_val:#x} | {rm_val:#x} = {result:#x}"
-            elif mnemonic == 'EOR' and '#' not in op_str: # EOR Xd, Xn, Xm
+
+            elif mnemonic == 'EOR' and len(op_str_parts) == 3: # EOR Xd, Xn, Xm
                 rd, rn, rm = op_str_parts
                 rn_val = self.get_reg(rn)
                 rm_val = self.get_reg(rm)
                 result = rn_val ^ rm_val
                 self.set_reg(rd, result)
                 result_str = f"; {rd} = {rn} ^ {rm} = {rn_val:#x} ^ {rm_val:#x} = {result:#x}"
 
-            # Add more instructions here (ANDI, ORRI, EORI, LSL, LSR, etc.)
+            # --- Load/Store (simplified) ---
+            elif mnemonic == 'LDR' and len(op_str_parts) == 2: # LDR Xt, [Xn]
+                rt, rn_mem = op_str_parts
+                if '[' in rn_mem and ']' in rn_mem:
+                    rn = rn_mem.split('[')[1].split(']')[0].strip()
+                    rn_val = self.get_reg(rn)
+                    # Simplified: just move address to destination
+                    self.set_reg(rt, rn_val)
+                    result_str = f"; {rt} = [{rn}] = {rn_val:#x} (simplified)"
+
+            # --- ADRP (simplified) ---
+            elif mnemonic == 'ADRP':
+                if len(op_str_parts) == 2:
+                    rd, imm_str = op_str_parts
+                    # Simplified ADRP: just store a dummy page address
+                    page_base = 0x400000  # Example page base
+                    self.set_reg(rd, page_base)
+                    result_str = f"; {rd} = page_base({imm_str}) = {page_base:#x} (simplified)"
 
         except Exception as e:
-            # Don't crash if parsing/emulation fails, just return empty string
-             # print(f"Emulator error: {e} on {mnemonic} {op_str}") # Optional debug
-             return ""
+            # Don't crash on emulation errors
+            return f"; Emulation error: {str(e)}"
 
         return result_str
 
 # ============================================================
 # FIXED INSTRUCTION CONVERTER
 # ============================================================
 class ARM64InstructionIO:
     def __init__(self):
-        self.cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)
-        self.cs.detail = True
+        self._cs = None
+
+    def _get_disassembler(self):
+        """Return a cached Capstone disassembler, creating it on demand."""
+        if self._cs is None:
+            self._cs = _create_disassembler()
+        return self._cs
 
     def _print_conversion_result(self, result):
         """Print conversion results in a formatted way"""
         if 'error' in result:
             print(f"  \033[91mError: {result['error']}\033[0m")
         else:
             print(f"  \033[96mAssembly:\033[0m {result.get('asm', 'N/A')}")
             print(f"  \033[96mHex:\033[0m      {result.get('hex', 'N/A')}")
             print(f"  \033[96mBytes (LE):\033[0m {result.get('bytes_le', 'N/A')}")
             print(f"  \033[96mBytes (BE):\033[0m {result.get('bytes_be', 'N/A')}")
 
     def hex_to_asm(self, hex_str):
         """Convert hex string to assembly instruction"""
         try:
             hex_str = hex_str.strip().replace(' ', '').replace('0x', '')
             if len(hex_str) != 8:
                 return {"error": f"Hex string must be 8 characters (got {len(hex_str)})"}
 
             value = int(hex_str, 16)
             bytes_le = value.to_bytes(4, 'little')
 
-            for insn in self.cs.disasm(bytes_le, 0):
+            cs = self._get_disassembler()
+            for insn in cs.disasm(bytes_le, 0):
                 return {
                     'hex': f"0x{value:08X}",
                     'asm': f"{insn.mnemonic} {insn.op_str}",
                     'bytes_le': bytes_le.hex().upper(),
                     'bytes_be': hex_str.upper()
                 }
             return {"error": f"Unknown or invalid instruction encoding: 0x{value:08X}"}
 
         except ValueError:
              return {"error": f"Invalid hex string: '{hex_str}'"}
+        except RuntimeError as exc:
+            return {"error": str(exc)}
         except Exception as e:
             return {"error": f"Conversion failed: {str(e)}"}
 
     def asm_to_hex(self, asm_text):
         """Convert assembly text to hex (limited support)"""
         try:
             asm_text_orig = asm_text.strip() # Keep original for output
             asm_text_upper = asm_text_orig.upper()
 
             # NOP instruction
             if asm_text_upper == "NOP":
                 encoding = 0xD503201F
                 return self._format_result("nop", encoding) # Use lowercase standard
 
             # ADD/SUB immediate patterns (Match W/X regs OR SP)
-            add_match = re.match(r'ADD\s+([WX]\d+|SP),\s*([WX]\d+|SP),\s*#?(0x[0-9A-F]+|\d+)', asm_text_upper)
+            add_match = re.match(r'ADD\s+([WX]\d+|SP),\s*([WX]\d+|SP),\s*#?(0X[0-9A-F]+|\d+)', asm_text_upper)
             if add_match:
                  return self._encode_add_sub_imm(asm_text_orig, "ADD", add_match)
 
-            sub_match = re.match(r'SUB\s+([WX]\d+|SP),\s*([WX]\d+|SP),\s*#?(0x[0-9A-F]+|\d+)', asm_text_upper)
+            sub_match = re.match(r'SUB\s+([WX]\d+|SP),\s*([WX]\d+|SP),\s*#?(0X[0-9A-F]+|\d+)', asm_text_upper)
             if sub_match:
                 return self._encode_add_sub_imm(asm_text_orig, "SUB", sub_match)
 
             # MOV immediate (using MOVZ)
-            mov_imm_match = re.match(r'MOV\s+([WX])(\d+),\s*#?(0x[0-9A-F]+|\d+)', asm_text_upper)
+            mov_imm_match = re.match(r'MOV\s+([WX])(\d+),\s*#?(0X[0-9A-F]+|\d+)', asm_text_upper)
             if mov_imm_match:
                 return self._encode_mov_imm(asm_text_orig, mov_imm_match)
 
             # MOV register (using ORR)
             mov_reg_match = re.match(r'MOV\s+([WX]\d+|SP),\s*([WX]\d+|XZR|WZR|SP)', asm_text_upper)
             if mov_reg_match:
                 return self._encode_mov_reg(asm_text_orig, mov_reg_match)
 
             return {"error": f"Assembly pattern not yet supported: '{asm_text}'"}
 
         except Exception as e:
             return {"error": f"Assembly parsing failed for '{asm_text}': {str(e)}"}
 
 
     def _parse_register(self, reg_str):
         """Parse register string like X0, W1, SP, XZR into (sf, index)"""
-        reg_str = reg_str.upper()
+        reg_str = reg_str.upper().strip()
+
         if reg_str == 'SP':
-            return 1, 31 # SP is X31
+            return 1, 31  # SP is X31
         elif reg_str in ('XZR', 'WZR'):
-            return 1, 31 # Treat like SP for encoding purposes where applicable, logic handles 0 value
+            return 1, 31  # Zero register is also X31
         elif reg_str.startswith('X'):
-            return 1, int(reg_str[1:])
+            reg_num = reg_str[1:]
+            if reg_num.isdigit():
+                return 1, int(reg_num)
         elif reg_str.startswith('W'):
-            return 0, int(reg_str[1:])
-        else:
-            raise ValueError(f"Invalid register '{reg_str}'")
+            reg_num = reg_str[1:]
+            if reg_num.isdigit():
+                return 0, int(reg_num)
+
+        raise ValueError(f"Invalid register '{reg_str}'")
 
     def _encode_add_sub_imm(self, asm_text, op, match):
         """Encode ADD/SUB immediate instructions, handling SP"""
         rd_str, rn_str, imm_str = match.groups()
 
         try:
             sf_d, rd = self._parse_register(rd_str)
             sf_n, rn = self._parse_register(rn_str)
         except ValueError as e:
             return {"error": str(e)}
 
-        # ADDI/SUBI requires registers to be the same size (or SP which implies 64-bit)
-        # Exception: ADD/SUB SP, SP, #imm is valid
+        # Determine if this is 64-bit operation
+        sf = 1 if (rd_str.startswith('X') or rd_str == 'SP' or rn_str == 'SP') else 0
+
+        # Validate register sizes
         if rd_str != 'SP' and rn_str != 'SP' and sf_d != sf_n:
-             return {"error": f"Register size mismatch in {op}"}
-        # If SP is involved, operation must be 64-bit
-        if (rd_str == 'SP' or rn_str == 'SP') and not sf_d: # Check sf_d because dest determines sf bit
-             return {"error": f"{op} with SP requires 64-bit destination (X register or SP)"}
+            return {"error": f"Register size mismatch in {op}"}
 
-        sf = 1 if (rd_str.startswith('X') or rd_str == 'SP') else 0
+        # SP operations must be 64-bit
+        if (rd_str == 'SP' or rn_str == 'SP') and not sf:
+            return {"error": f"{op} with SP requires 64-bit destination"}
 
         imm_val = int(imm_str, 0)
         shift = 0
 
-        if 0 <= imm_val <= 0xFFF: # 0 to 4095
+        # Handle the immediate encoding
+        if 0 <= imm_val <= 0xFFF:  # 0 to 4095
             shift = 0
-        elif 0 < imm_val <= (0xFFF << 12) and imm_val % (1 << 12) == 0:
+        elif 0 <= imm_val <= 0xFFFFFF and (imm_val & 0xFFF) == 0:
+            # Multiple of 4096, use LSL #12
             imm_val = imm_val >> 12
-            shift = 1 # LSL #12
+            shift = 1
         else:
-            limit = 0xFFFFFF if sf == 1 else 0xFFF # More complex if shifted? Let's stick to 12bit + shift
-            limit = (0xFFF << 12 | 0xFFF) # Max value representable
-            return {"error": f"Invalid {op} immediate. Must be 0-4095 or a multiple of 4096 up to {limit:#x}"}
+            return {"error": f"Invalid {op} immediate {imm_val:#x}. Must be 0-4095 or a multiple of 4096"}
+
+        # Choose the correct base encoding
+        if sf:  # 64-bit
+            base_add = 0x91000000
+            base_sub = 0xD1000000
+        else:   # 32-bit
+            base_add = 0x11000000
+            base_sub = 0x51000000
 
-        # Use 64-bit base if sf=1, 32-bit otherwise
-        base_add = 0x91000000 if sf else 0x11000000
-        base_sub = 0xD1000000 if sf else 0x51000000
         base = base_add if op == "ADD" else base_sub
 
+        # Assemble the instruction: base | (shift << 22) | (imm12 << 10) | (Rn << 5) | Rd
         encoding = base | (shift << 22) | (imm_val << 10) | (rn << 5) | rd
         return self._format_result(asm_text, encoding)
 
 
     def _encode_mov_imm(self, asm_text, match):
         """Encode MOV immediate (using MOVZ)"""
         size, rd_str, imm_str = match.groups()
         sf = 1 if size == 'X' else 0
         rd = int(rd_str)
         imm_val = int(imm_str, 0)
 
         # Simplest case: MOVZ with hw=0
         if 0 <= imm_val <= 0xFFFF:
             hw = 0
             imm16 = imm_val
             # MOVZ encoding base depends on sf
             base = 0xD2800000 if sf else 0x52800000
             encoding = base | (hw << 21) | (imm16 << 5) | rd
             return self._format_result(asm_text, encoding)
         # Add MOVN/MOVK logic here if needed for larger/negative immediates
 
         return {"error": f"Cannot encode immediate {imm_val:#x} with simple MOVZ. Need MOVN/MOVK logic."}
 
 
     def _encode_mov_reg(self, asm_text, match):
@@ -1039,100 +1094,108 @@ class ARM64InstructionIO:
             sf_d, rd = self._parse_register(rd_str)
             sf_m, rm = self._parse_register(rm_str)
         except ValueError as e:
             return {"error": str(e)}
 
         # Check for size mismatch, allowing ZR registers
         if rm_str not in ('XZR', 'WZR') and rd_str != 'SP' and rm_str != 'SP' and sf_d != sf_m:
              return {"error": "Register size mismatch in MOV"}
 
         # Determine sf bit based on destination (or source if dest is SP?)
         # Standard alias uses size of operands. SP implies 64-bit.
         sf = 1 if (rd_str.startswith('X') or rd_str == 'SP' or rm_str.startswith('X') or rm_str == 'SP') else 0
 
         # MOV Rd, Rm is alias for ORR Rd, XZR/WZR, Rm
         # Need Rn=31 (XZR/WZR)
         rn = 31
         # ORR encoding base depends on sf
         base = 0xAA000000 if sf else 0x2A000000
         # ORR Rd, Rn, Rm -> sf:op:S:....:shift:Rm:imm6:Rn:Rd
         # We need shift=0, imm6=0
         encoding = base | (rm << 16) | (rn << 5) | rd
         return self._format_result(asm_text, encoding)
 
     def _format_result(self, asm_text, encoding):
         """Format conversion result consistently"""
-        disasm_result = self.hex_to_asm(f"{encoding:08X}")
-        canonical_asm = disasm_result.get('asm', asm_text) # Use re-disassembled asm if possible
-
-        # Don't show original asm if it failed re-disassembly
-        if 'error' in disasm_result:
-             asm_to_show = f"<Encoding Error: {disasm_result['error']}>"
+        if Cs is None:
+            asm_to_show = asm_text
         else:
-             asm_to_show = canonical_asm
+            disasm_result = self.hex_to_asm(f"{encoding:08X}")
+            canonical_asm = disasm_result.get('asm', asm_text) # Use re-disassembled asm if possible
 
+            # Don't show original asm if it failed re-disassembly
+            if 'error' in disasm_result:
+                 asm_to_show = f"<Encoding Error: {disasm_result['error']}>"
+            else:
+                 asm_to_show = canonical_asm
 
         return {
             'asm': asm_to_show,
             'hex': f"0x{encoding:08X}",
             'bytes_le': encoding.to_bytes(4, 'little').hex().upper(),
             'bytes_be': f"{encoding:08X}"
         }
 
     def interactive_converter(self):
         """Interactive instruction converter"""
         print("\n=== GEMi Interactive Instruction Converter ===")
         print("  Type 'hex <value>', 'asm <instruction>', 'arch [version]', or 'quit'")
 
         while True:
             try:
                 user_input = input("\nGEMi> ").strip()
-                if not user_input: continue
+                if not user_input:
+                    continue
 
                 if user_input.lower() in ['quit', 'exit', 'q']:
                     break
                 elif user_input.lower().startswith('hex '):
                     hex_str = user_input[4:].strip()
                     result = self.hex_to_asm(hex_str)
                     self._print_conversion_result(result)
                 elif user_input.lower().startswith('asm '):
                     asm_text = user_input[4:].strip()
                     result = self.asm_to_hex(asm_text)
                     self._print_conversion_result(result)
                 elif user_input.lower() == 'help':
-                    print("  Commands: hex <value>, asm <instruction>, arch [version], quit")
+                    print("  Commands:")
+                    print("    hex <value>        - Convert hex to assembly")
+                    print("    asm <instruction>  - Convert assembly to hex")
+                    print("    arch [version]     - Show architecture info")
+                    print("    quit               - Exit")
                 elif user_input.lower().startswith('arch'):
                     parts = user_input.split()
-                    version = parts[1].upper() if len(parts) > 1 else None
-                    show_architecture_info(version)
+                    version = parts[1] if len(parts) > 1 else None
+                    show_architecture_info(version.upper() if version else None)
                 else:
                     print("  Unknown command. Type 'help' for options.")
             except KeyboardInterrupt:
                 print("\nExiting...")
                 break
             except Exception as e:
-                print(f"  \033[91mError during processing: {e}\033[0m")
+                print(f"  \033[91mError: {e}\033[0m")
+                print("  Type 'help' for available commands")
 
 
 # ============================================================
 # CORE EXPLORATION FUNCTIONS
 # ============================================================
 def disassemble_word(value, cs):
     code = value.to_bytes(4, "little")
     for insn in cs.disasm(code, 0):
         return insn.mnemonic, insn.op_str # Return separately
     return None, None # Indicate failure
 
 
 def get_binary_pattern(base, mask):
     # ... (same as before) ...
     out_bits = []
     for i in range(31, -1, -1):
         if (mask >> i) & 1:
             out_bits.append(str((base >> i) & 1))
         else:
             out_bits.append("x")
     bitstr = "".join(out_bits)
     return " ".join(bitstr[i:i+4] for i in range(0, 32, 4))
 
 
 def colorize_bits(base, mask, val):
@@ -1430,116 +1493,124 @@ Examples:
   %(prog)s CMP --vary Rn Rm --lock sf=1      # Explore CMP (alias)
 """
     )
 
     parser.add_argument("opcode", nargs="?", help="Opcode mnemonic or value for --convert") # Modified help
 
     explore_group_args = parser.add_argument_group('Exploration')
     explore_group_args.add_argument("--group", dest="group_name", help="Explore an ISA group")
     explore_group_args.add_argument("--summary", action="store_true", help="Show summary of all encodings")
     explore_group_args.add_argument("--describe", help="Show summary for a single opcode")
     explore_group_args.add_argument("--vary", nargs="*", help="Fields to vary (default: all)")
     explore_group_args.add_argument("--lock", nargs="*", help="Lock specific fields")
     explore_group_args.add_argument("--limit", type=int, default=32, help="Max encodings to print")
     explore_group_args.add_argument("--step", type=int, default=4, help="Step for sweeping large fields")
 
     convert_group_args = parser.add_argument_group('Conversion')
     convert_group_args.add_argument("--convert", choices=["hex", "asm"], help="Convert hex-to-asm or asm-to-hex")
     convert_group_args.add_argument("--value", help="Value to convert (alternative to positional)")
     convert_group_args.add_argument("--interactive", "-i", action="store_true", help="Start interactive converter")
 
     arch_group_args = parser.add_argument_group('Architecture Info')
     arch_group_args.add_argument("--arch", help="Show architecture specifications")
     arch_group_args.add_argument("--list-arch", action="store_true", help="List all architectures")
 
     args = parser.parse_args()
-    cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)
-    io_system = ARM64InstructionIO()
-    locks = parse_locks(args.lock)
-    emulator = Emulator() # Create emulator instance for single opcode exploration
-
-    # --- FIXED ROUTING ORDER ---
-    # Handle conversion first
-    value_to_convert = args.value
-    if args.convert:
-        # If --value wasn't provided, use the positional 'opcode' arg
-        if not value_to_convert and args.opcode:
-            value_to_convert = args.opcode
-            args.opcode = None # Clear opcode so it doesn't fall through
-
-        if not value_to_convert:
-            parser.error("--convert requires a value (use --value or provide value positionally)")
-
-        if args.convert == "hex":
-            result = io_system.hex_to_asm(value_to_convert)
-        else: # asm
-            result = io_system.asm_to_hex(value_to_convert)
-        io_system._print_conversion_result(result)
-        return
 
-    # Handle interactive mode
-    if args.interactive:
-        io_system.interactive_converter()
-        return
+    try:
+        io_system = ARM64InstructionIO()
+        locks = parse_locks(args.lock)
+        emulator = Emulator() # Create emulator instance for single opcode exploration
+        cs = None
+
+        # --- FIXED ROUTING ORDER ---
+        # Handle conversion first
+        value_to_convert = args.value
+        if args.convert:
+            # If --value wasn't provided, use the positional 'opcode' arg
+            if not value_to_convert and args.opcode:
+                value_to_convert = args.opcode
+                args.opcode = None # Clear opcode so it doesn't fall through
+
+            if not value_to_convert:
+                parser.error("--convert requires a value (use --value or provide value positionally)")
+
+            if args.convert == "hex":
+                result = io_system.hex_to_asm(value_to_convert)
+            else: # asm
+                result = io_system.asm_to_hex(value_to_convert)
+            io_system._print_conversion_result(result)
+            return
 
-    # Handle architecture info
-    if args.arch or args.list_arch:
-        show_architecture_info(args.arch.upper() if args.arch else None)
-        return
+        # Handle interactive mode
+        if args.interactive:
+            io_system.interactive_converter()
+            return
 
-    # Handle summary
-    if args.summary:
-        summary_all()
-        return
+        # Handle architecture info
+        if args.arch or args.list_arch:
+            show_architecture_info(args.arch.upper() if args.arch else None)
+            return
+
+        # Handle summary
+        if args.summary:
+            summary_all()
+            return
+
+        # Handle describe
+        if args.describe:
+            dname = args.describe.upper()
+            # Handle aliases *before* checking OPCODE_MAP
+            if dname in INSTRUCTION_ALIASES:
+                alias_spec = INSTRUCTION_ALIASES[dname]
+                base_op = alias_spec["base_op"]
+                print(f"\033[96mNote: {dname} is an alias for {base_op} with fields {alias_spec['locked_fields']}\033[0m")
+                # Apply alias locks, user locks take precedence
+                for field, value in alias_spec['locked_fields'].items():
+                    if field not in locks: locks[field] = value
+                dname = base_op # Use the base opcode for description
+
+            if dname not in OPCODE_MAP:
+                print(f"\033[91mUnknown opcode '{dname}' for describe.\033[0m")
+                print("Known opcodes:", ", ".join(sorted(OPCODE_MAP.keys())))
+                return
+            describe_opcode(dname, locks)
+            return
+
+        # Handle group exploration
+        if args.group_name:
+            cs = cs or _create_disassembler()
+            explore_group(args.group_name, cs, args.limit, args.step, args.vary, locks)
+            return
+
+        # Handle single opcode exploration (default if nothing else matched)
+        if not args.opcode:
+            parser.print_help()
+            sys.exit("\n\033[91mError: No opcode, group, or mode specified. See usage examples.\033[0m")
+
+        opname = args.opcode.upper()
 
-    # Handle describe
-    if args.describe:
-        dname = args.describe.upper()
         # Handle aliases *before* checking OPCODE_MAP
-        if dname in INSTRUCTION_ALIASES:
-            alias_spec = INSTRUCTION_ALIASES[dname]
+        if opname in INSTRUCTION_ALIASES:
+            alias_spec = INSTRUCTION_ALIASES[opname]
             base_op = alias_spec["base_op"]
-            print(f"\033[96mNote: {dname} is an alias for {base_op} with fields {alias_spec['locked_fields']}\033[0m")
-            # Apply alias locks, user locks take precedence
+            print(f"\033[96mNote: {opname} is an alias for {base_op} with locked fields {alias_spec['locked_fields']}\033[0m")
             for field, value in alias_spec['locked_fields'].items():
                 if field not in locks: locks[field] = value
-            dname = base_op # Use the base opcode for description
+            opname = base_op # Use the base opcode for exploration
 
-        if dname not in OPCODE_MAP:
-            print(f"\033[91mUnknown opcode '{dname}' for describe.\033[0m")
+        if opname not in OPCODE_MAP:
+            print(f"\033[91mUnknown opcode '{opname}' for exploration.\033[0m")
             print("Known opcodes:", ", ".join(sorted(OPCODE_MAP.keys())))
             return
-        describe_opcode(dname, locks)
-        return
 
-    # Handle group exploration
-    if args.group_name:
-        explore_group(args.group_name, cs, args.limit, args.step, args.vary, locks)
-        return
+        spec = OPCODE_MAP[opname]
+        cs = cs or _create_disassembler()
+        explore_opcode(opname, spec, cs, args.limit, args.step, args.vary, locks, emulator) # Pass emulator
 
-    # Handle single opcode exploration (default if nothing else matched)
-    if not args.opcode:
-        parser.print_help()
-        sys.exit("\n\033[91mError: No opcode, group, or mode specified. See usage examples.\033[0m")
-
-    opname = args.opcode.upper()
-
-    # Handle aliases *before* checking OPCODE_MAP
-    if opname in INSTRUCTION_ALIASES:
-        alias_spec = INSTRUCTION_ALIASES[opname]
-        base_op = alias_spec["base_op"]
-        print(f"\033[96mNote: {opname} is an alias for {base_op} with locked fields {alias_spec['locked_fields']}\033[0m")
-        for field, value in alias_spec['locked_fields'].items():
-            if field not in locks: locks[field] = value
-        opname = base_op # Use the base opcode for exploration
-
-    if opname not in OPCODE_MAP:
-        print(f"\033[91mUnknown opcode '{opname}' for exploration.\033[0m")
-        print("Known opcodes:", ", ".join(sorted(OPCODE_MAP.keys())))
-        return
-
-    spec = OPCODE_MAP[opname]
-    explore_opcode(opname, spec, cs, args.limit, args.step, args.vary, locks, emulator) # Pass emulator
+    except Exception as e:
+        print(f"\033[91mFatal error: {e}\033[0m")
+        sys.exit(1)
 
 
 if __name__ == "__main__":
     main()
